import { Lib } from '@locker/ast-lib-maker/types';
import * as ESLint from 'eslint';
declare type RuleCreate = (context: ESLint.Rule.RuleContext) => ESLint.Rule.NodeListener | ESLint.Rule.RuleListener | (ESLint.Rule.NodeListener & ESLint.Rule.RuleListener);
declare type RuleFix = ((fixer: ESLint.Rule.RuleFixer, matchData?: Rule.MatchData) => null | ESLint.Rule.Fix | IterableIterator<ESLint.Rule.Fix> | ESLint.Rule.Fix[]) | null | string;
declare type RuleMessage = ((data: Rule.MatchData) => string) | string;
interface RuleMatchData extends Lib.MatchData {
    context: ESLint.Rule.RuleContext;
}
declare type RuleOnMatch = (data: Rule.MatchData) => Rule.MatchOverride | boolean;
export declare namespace CreateRule {
    interface Config {
        create?: RuleCreate;
        meta?: ESLint.Rule.RuleMetaData;
        rule?: {
            fix?: RuleFix;
            message?: RuleMessage;
            onMatch?: RuleOnMatch;
            search: Lib.SearchPattern[] | Rule.SearchPattern[];
        };
    }
    interface ConfigStrict {
        create?: RuleCreate;
        meta: ESLint.Rule.RuleMetaData;
        rule: {
            fix?: RuleFix;
            message?: RuleMessage;
            onMatch?: RuleOnMatch;
            search: Lib.SearchPatternArray[] | Rule.SearchPatternArray[];
        };
    }
}
export declare namespace Rule {
    type MatchData = RuleMatchData & Lib.MatchData;
    interface MatchOverride {
        fix?: RuleFix;
        message?: RuleMessage;
    }
    type SearchPattern = Lib.SearchPattern;
    type SearchPatternArray = Lib.SearchPatternArray;
    type SearchPatternString = Lib.SearchPatternString;
}
export {};
//# sourceMappingURL=types.d.ts.map