import { AST } from '@locker/ast-lib-maker/types';
import * as ESLint from 'eslint';
import * as ESTree from 'estree';
import { CreateRule, Rule } from './types';
export declare const astLib: {
    expandPatterns(patterns: import("@locker/ast-lib-maker").Lib.SearchPatternArray | import("@locker/ast-lib-maker").Lib.SearchPatternArray[]): import("@locker/ast-lib-maker").Lib.SearchPatternArray[];
    getIdentifierName(node: ESTree.Identifier): string;
    getParent(node: AST.Node): AST.MaybeNode;
    getType(node: AST.Node): string;
    isMatchableNode(node: AST.MaybeNode): boolean;
    isNodeByAsteriskOrName(node: AST.MaybeNode, name: string): boolean;
    isNonComputedMemberExpressionNode(node: AST.MaybeNode): boolean;
    match(identifier: AST.IdentifierOrThisExpression, patterns: string | import("@locker/ast-lib-maker").Lib.SearchPatternArray | import("@locker/ast-lib-maker").Lib.SearchPatternArray[]): import("@locker/ast-lib-maker").Lib.MatchData | undefined;
    matchAll(identifiers: AST.IdentifierOrThisExpression[], patterns: string | import("@locker/ast-lib-maker").Lib.SearchPatternArray | import("@locker/ast-lib-maker").Lib.SearchPatternArray[]): import("@locker/ast-lib-maker").Lib.MatchData[];
};
declare function matchAsNonReadableNonWritable({ node }: Rule.MatchData): Rule.MatchOverride | boolean;
declare function matchAsNonWritable({ node }: Rule.MatchData): Rule.MatchOverride | boolean;
declare function matchAsNullishAndNonWritable(data: Rule.MatchData): Rule.MatchOverride | boolean;
export declare const matchers: {
    matchAsNonReadableNonWritable: typeof matchAsNonReadableNonWritable;
    matchAsNonWritable: typeof matchAsNonWritable;
    matchAsNullishAndNonWritable: typeof matchAsNullishAndNonWritable;
};
export declare function createRule(config: CreateRule.Config): ESLint.Rule.RuleModule;
export * from './types';
//# sourceMappingURL=index.d.ts.map