/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const {
  apply: ReflectApply,
  construct: ReflectConstruct,
  deleteProperty: ReflectDeleteProperty,
  has: ReflectHas,
  get: ReflectGet,
  getPrototypeOf: ReflectGetPrototypeOf,
  set: ReflectSet,
  setPrototypeOf: ReflectSetPrototypeOf$1,
  defineProperty: ReflectDefineProperty,
  isExtensible: ReflectIsExtensible,
  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,
  ownKeys: ReflectOwnKeys$1,
  preventExtensions: ReflectPreventExtensions
} = Reflect;
const {
  filter: ArrayProtoFilter,
  includes: ArrayProtoIncludes,
  indexOf: ArrayProtoIndexOf,
  join: ArrayProtoJoin,
  slice: ArrayProtoSlice,
  some: ArrayProtoSome
} = Array.prototype;
const ArrayCtor = Array;
const {
  from: ArrayFrom,
  isArray: ArrayIsArray
} = Array;
const {
  push: ArrayProtoPush
} = Array.prototype;

function ArrayConcat(arr) {
  // Reimplement Array#concat to avoid prototype poisoning from Symbol.isConcatSpreadable.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable
  const result = ReflectApply(ArrayProtoSlice, arr, [0]);

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  const {
    length
  } = args;

  for (let i = 0; i < length; i += 1) {
    const value = args[i];
    ReflectApply(ArrayProtoPush, result, ArrayIsArray(value) ? value : [value]);
  }

  return result;
}

function ArrayFilter(arr, iteratee) {
  return ReflectApply(ArrayProtoFilter, arr, [iteratee]);
}

function ArrayIncludes(arr, value) {
  return ReflectApply(ArrayProtoIncludes, arr, [value]);
}

function ArrayIndexOf(arr) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  return ReflectApply(ArrayProtoIndexOf, arr, args);
}

function ArrayJoin(arr) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return ReflectApply(ArrayProtoJoin, arr, args);
}

function ArrayPush(arr) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }

  return ReflectApply(ArrayProtoPush, arr, args);
}

function ArrayShallowClone(arr) {
  return ArraySlice(arr, 0);
}

function ArraySlice(arr) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  return ReflectApply(ArrayProtoSlice, arr, args);
}

function ArraySome(arr, iteratee) {
  return ReflectApply(ArrayProtoSome, arr, [iteratee]);
}

const emptyArray = [];
const {
  create: ObjectCreate$1
} = Object;
const {
  ownKeys: ReflectOwnKeys,
  setPrototypeOf: ReflectSetPrototypeOf
} = Reflect;

function isObject(value) {
  return typeof value === 'object' && value !== null;
}

function isObjectLike(value) {
  return typeof value === 'function' || typeof value === 'object' && value !== null;
}

function shallowCloneOptions(options) {
  const keys = ReflectOwnKeys(options);
  const clone = ObjectCreate$1(null);

  for (let i = 0, len = keys.length; i < len; i += 1) {
    const key = keys[i];
    clone[key] = options[key];
  }

  return clone;
}

function toSafeDescriptorMap(descriptorMap) {
  // Descriptor maps are not susceptible to Object.prototype pollution because
  // the internal operation uses [[OwnPropertyKeys]]:
  // https://tc39.es/ecma262/#sec-objectdefineproperties.
  //
  // However, their descriptors are because the internal operation uses
  // [[HasProperty]]: https://tc39.es/ecma262/#sec-topropertydescriptor.
  const props = ReflectOwnKeys(descriptorMap);

  for (let i = 0, len = props.length; i < len; i += 1) {
    ReflectSetPrototypeOf(descriptorMap[props[i]], null);
  }

  return descriptorMap;
}

function toBoolean(value) {
  return !!value;
}

const {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  __lookupGetter__: ObjectProto__lookupGetter__,
  // eslint-disable-next-line @typescript-eslint/naming-convention
  __lookupSetter__: ObjectProto__lookupSetter__,
  hasOwnProperty: ObjectProtoHasOwnProperty
} = Object.prototype;
const {
  assign: ObjectAssign,
  create: ObjectCreate,
  defineProperty: ObjectDefineProperty,
  defineProperties: ObjectDefineProperties,
  getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors,
  freeze: ObjectFreeze,
  getOwnPropertyNames: ObjectGetOwnPropertyNames,
  getOwnPropertySymbols: ObjectGetOwnPropertySymbols,
  keys: ObjectKeys,
  seal: ObjectSeal,
  isSealed: ObjectIsSealed,
  isFrozen: ObjectIsFrozen,
  preventExtensions: ObjectPreventExtensions
} = Object;

function ObjectHasOwnProperty(obj, key) {
  return obj !== null && obj !== undefined && ReflectApply(ObjectProtoHasOwnProperty, obj, [key]);
}

function ObjectLookupOwnGetter(obj, key) {
  if (obj === null || obj === undefined || !ReflectApply(ObjectProtoHasOwnProperty, obj, [key])) {
    return undefined;
  }

  return ReflectApply(ObjectProto__lookupGetter__, obj, [key]);
}

function ObjectLookupOwnSetter(obj, key) {
  if (obj === null || obj === undefined || !ReflectApply(ObjectProtoHasOwnProperty, obj, [key])) {
    return undefined;
  }

  return ReflectApply(ObjectProto__lookupSetter__, obj, [key]);
}

function ObjectLookupOwnValue(obj, key) {
  if (obj === null || obj === undefined || !ReflectApply(ObjectProtoHasOwnProperty, obj, [key])) {
    return undefined;
  }

  return obj[key];
}

const ProxyCtor = Proxy;
const ProxyRevocable = Proxy.revocable;

function maskDistortion(distortedFunc, rawFunc) {
  const proxy = new ProxyCtor(rawFunc, ObjectFreeze({
    apply(target, thisArg, args) {
      if (thisArg === proxy) {
        thisArg = distortedFunc;
      }

      return ReflectApply(distortedFunc, thisArg, args);
    },

    construct(target, args, newTarget) {
      if (newTarget === proxy) {
        newTarget = distortedFunc;
      }

      return ReflectConstruct(distortedFunc, args, newTarget);
    }

  }));
  return proxy;
}

function createRevokedProxy(object) {
  const revocable = ProxyRevocable(object, ObjectCreate(null));
  revocable.revoke();
  return revocable.proxy;
}
/* eslint-disable max-classes-per-file */


const ErrorCtor = Error;
const RangeErrorCtor = RangeError;
const TypeErrorCtor = TypeError;

class LockerSecurityError extends Error {}

class LockerRangeError extends LockerSecurityError {}

const {
  bind: FunctionProtoBind
} = Function.prototype;

const FunctionBind = (func, thisArg) => ReflectApply(FunctionProtoBind, func, [thisArg]);

function wrap(func, wrapper) {
  return function wrapped() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    return ReflectApply(wrapper, this, [func, args]);
  };
}

const {
  parse: JSONParse,
  stringify: JSONStringify
} = JSON;
const {
  for: SymbolFor,
  iterator: SymbolIterator
} = Symbol;
const SYMBOL_LIVE_OBJECT = SymbolFor('@@lockerLiveValue');

function markLiveObject(object) {
  ReflectDefineProperty(object, SYMBOL_LIVE_OBJECT, {
    value: undefined,
    configurable: false,
    enumerable: false,
    writable: false
  });
  return object;
}

function isLiveObject(object) {
  return ObjectHasOwnProperty(object, SYMBOL_LIVE_OBJECT);
}

const {
  entries: MapProtoEntries,
  forEach: MapProtoForEach,
  set: MapProtoSet
} = Map.prototype;
const MapCtor = Map;

function MapEntries(map) {
  return ReflectApply(MapProtoEntries, map, emptyArray);
}

function MapForEach(map, iteratee) {
  return ReflectApply(MapProtoForEach, map, [iteratee]);
}

function MapSet(map, key, value) {
  return ReflectApply(MapProtoSet, map, [key, value]);
}

const MathMin = Math.min;
const {
  then: PromiseProtoThen
} = Promise.prototype;

function PromiseThen(promise) {
  for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
    args[_key7 - 1] = arguments[_key7];
  }

  return ReflectApply(PromiseProtoThen, promise, [args]);
}

const StringCtor = String;
const {
  charCodeAt: StringProtoCharCodeAt,
  includes: StringProtoIncludes,
  match: StringProtoMatch,
  replace: StringProtoReplace,
  slice: StringProtoSlice,
  split: StringProtoSplit,
  substring: StringProtoSubstring,
  startsWith: StringProtoStartsWith,
  toLowerCase: StringProtoToLowerCase,
  toUpperCase: StringProtoToUpperCase
} = String.prototype;

function StringCharCodeAt(str, index) {
  return ReflectApply(StringProtoCharCodeAt, str, [index]);
}

function StringIncludes(str) {
  for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
    args[_key8 - 1] = arguments[_key8];
  }

  return ReflectApply(StringProtoIncludes, str, args);
}

function StringMatch(str, regexp) {
  return ReflectApply(StringProtoMatch, str, [regexp]);
}

function StringReplace(str, pattern, replacement) {
  return ReflectApply(StringProtoReplace, str, [pattern, replacement]);
}

function StringSlice(str) {
  for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
    args[_key9 - 1] = arguments[_key9];
  }

  return ReflectApply(StringProtoSlice, str, args);
}

function StringSplit(str) {
  for (var _len10 = arguments.length, args = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
    args[_key10 - 1] = arguments[_key10];
  }

  return ReflectApply(StringProtoSplit, str, args);
}

function StringSubstring(str) {
  for (var _len11 = arguments.length, args = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
    args[_key11 - 1] = arguments[_key11];
  }

  return ReflectApply(StringProtoSubstring, str, args);
}

function StringStartsWith(str) {
  for (var _len12 = arguments.length, args = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {
    args[_key12 - 1] = arguments[_key12];
  }

  return ReflectApply(StringProtoStartsWith, str, args);
}

function StringToLowerCase(str) {
  return ReflectApply(StringProtoToLowerCase, str, emptyArray);
}

function StringToUpperCase(str) {
  return ReflectApply(StringProtoToUpperCase, str, emptyArray);
}

function capitalize(str) {
  return str.length ? `${StringToUpperCase(str[0])}${StringSlice(str, 1)}` : '';
}

function toString(value) {
  try {
    return StringCtor(value);
  } catch (_unused) {
    return '';
  }
}

function toStringIfNotNullOrUndefined(value) {
  return value === null || value === undefined ? value : toString(value);
}

const {
  test: RegExpProtoTest
} = RegExp.prototype;
const specialCharRegExp = /[\\^$.*+?()[\]{}|]/g;

function RegExpTest(regexp, content) {
  return ReflectApply(RegExpProtoTest, regexp, [toString(content)]);
}

function escapeRegExp(string) {
  return StringReplace(string, specialCharRegExp, '\\$&');
} // To sanitizeArguments that require no transformation


function toIgnore(value) {
  return value;
}

function sanitizeArguments(args, sanitizers) {
  const argsLen = args.length;
  const sLen = sanitizers.length;
  const len = MathMin(argsLen, sLen);
  const sanitizedArgs = ArrayFrom(args);

  for (let i = 0; i < len; i += 1) {
    sanitizedArgs[i] = sanitizers[i](args[i]);
  }

  return sanitizedArgs;
}

const {
  add: SetProtoAdd,
  delete: SetProtoDelete,
  has: SetProtoHas
} = Set.prototype;
const SetCtor = Set;

function SetAdd(set, value) {
  return ReflectApply(SetProtoAdd, set, [value]);
}

function SetDelete(set, value) {
  return ReflectApply(SetProtoDelete, set, [value]);
}

function SetHas(set, value) {
  return ReflectApply(SetProtoHas, set, [value]);
}

const {
  get: WeakMapProtoGet,
  set: WeakMapProtoSet
} = WeakMap.prototype;
const WeakMapCtor = WeakMap;

function WeakMapGet(weakMap, key) {
  return ReflectApply(WeakMapProtoGet, weakMap, [key]);
}

function WeakMapSet(weakMap, key, value) {
  return ReflectApply(WeakMapProtoSet, weakMap, [key, value]);
}

export { ArrayConcat, ArrayCtor, ArrayFilter, ArrayFrom, ArrayIncludes, ArrayIndexOf, ArrayIsArray, ArrayJoin, ArrayProtoPush, ArrayPush, ArrayShallowClone, ArraySlice, ArraySome, ErrorCtor, FunctionBind, JSONParse, JSONStringify, LockerRangeError, LockerSecurityError, MapCtor, MapEntries, MapForEach, MapSet, MathMin, ObjectAssign, ObjectCreate, ObjectDefineProperties, ObjectDefineProperty, ObjectFreeze, ObjectGetOwnPropertyDescriptors, ObjectGetOwnPropertyNames, ObjectGetOwnPropertySymbols, ObjectHasOwnProperty, ObjectIsFrozen, ObjectIsSealed, ObjectKeys, ObjectLookupOwnGetter, ObjectLookupOwnSetter, ObjectLookupOwnValue, ObjectPreventExtensions, ObjectSeal, PromiseThen, ProxyCtor, ProxyRevocable, RangeErrorCtor, ReflectApply, ReflectConstruct, ReflectDefineProperty, ReflectDeleteProperty, ReflectGet, ReflectGetOwnPropertyDescriptor, ReflectGetPrototypeOf, ReflectHas, ReflectIsExtensible, ReflectOwnKeys$1 as ReflectOwnKeys, ReflectPreventExtensions, ReflectSet, ReflectSetPrototypeOf$1 as ReflectSetPrototypeOf, RegExpTest, SYMBOL_LIVE_OBJECT, SetAdd, SetCtor, SetDelete, SetHas, StringCharCodeAt, StringIncludes, StringMatch, StringReplace, StringSlice, StringSplit, StringStartsWith, StringSubstring, StringToLowerCase, StringToUpperCase, SymbolFor, SymbolIterator, TypeErrorCtor, WeakMapCtor, WeakMapGet, WeakMapSet, capitalize, createRevokedProxy, emptyArray, escapeRegExp, isLiveObject, isObject, isObjectLike, markLiveObject, maskDistortion, sanitizeArguments, shallowCloneOptions, toBoolean, toIgnore, toSafeDescriptorMap, toString, toStringIfNotNullOrUndefined, wrap };
/*! version: 0.14.7 */
