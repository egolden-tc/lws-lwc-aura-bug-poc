/*!
 * Copyright (C) 2020 salesforce.com, inc.
 */
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { JSONStringify, JSONParse, ArrayIsArray } from '@locker/shared';
const ASTERISK_CHARACTER = '*';
const DOCUMENT_ALIASES = [`${ASTERISK_CHARACTER}.ownerDocument`, 'document'];
const WINDOW_ALIASES = ['document.defaultView', 'frames', 'globalThis', 'self', 'window'];
const expandPatternsCache = new Map();

function dehydratePattern(pattern) {
  return ArrayIsArray(pattern) ? pattern.join('.') : String(pattern);
}

function ensureArray(value) {
  return ArrayIsArray(value) ? value : [value];
}

function expandPattern(pattern) {
  const expandedPatterns = [rehydratePattern(normalizePattern(pattern))];
  const dehydratedPatterns = expandedPatterns.map(dehydratePattern);

  function push(stringPattern) {
    if (!dehydratedPatterns.includes(stringPattern)) {
      dehydratedPatterns.push(stringPattern);
      expandedPatterns.push(rehydratePattern(stringPattern));
    }
  }

  function pushAliases(aliases, pathTail) {
    for (let i = 0, {
      length
    } = aliases; i < length; i += 1) {
      push(`${aliases[i]}.${pathTail}`);
    }
  }

  for (let i = 0, {
    length
  } = dehydratedPatterns; i < length; i += 1) {
    const stringPattern = dehydratedPatterns[i]; // Skip empty patterns and those starting with '*.'.

    if (stringPattern === '' || stringPatternStartsWith(stringPattern, ASTERISK_CHARACTER)) {
      continue;
    }

    const topLevelPath = isWindowStringPattern(stringPattern) ? stringPatternTail(stringPattern) : stringPattern; // Expand patterns with a top-level identifier.

    push(topLevelPath); // Expand patterns with other `window` aliases.

    pushAliases(WINDOW_ALIASES, topLevelPath); // Expand patterns with other `document` aliases.

    if (isDocumentStringPattern(topLevelPath)) {
      pushAliases(DOCUMENT_ALIASES, stringPatternTail(topLevelPath));
    }
  }

  return expandedPatterns;
}

function isDocumentStringPattern(stringPattern) {
  return stringPatternStartsWithByAliases(stringPattern, DOCUMENT_ALIASES);
}

function isWindowStringPattern(stringPattern) {
  return stringPatternStartsWithByAliases(stringPattern, WINDOW_ALIASES);
}

function normalizePattern(pattern) {
  return ArrayIsArray(pattern) ? pattern.map(removeWhitespace) : removeWhitespace(pattern);
}

function rehydratePattern(pattern) {
  return ArrayIsArray(pattern) ? pattern : String(pattern).split('.');
}

function removeWhitespace(string) {
  return String(string).replace(/\s/g, '');
}

function stringPatternStartsWith(stringPattern, searchString) {
  return stringPattern.startsWith(`${searchString}.`);
}

function stringPatternStartsWithByAliases(stringPattern, aliases) {
  for (let i = 0, {
    length
  } = aliases; i < length; i += 1) {
    if (stringPatternStartsWith(stringPattern, aliases[i])) {
      return true;
    }
  }

  return false;
}

function stringPatternTail(stringPattern) {
  return stringPattern.slice(stringPattern.indexOf('.') + 1);
}

const baseLib = {
  /**
   * String patterns are converted to arrays and expanded for document and
   * window aliases. For example:
   * ```js
   * ['window.top']
   * ```
   * expands to:
   * ```js
   * [
   *   ['window', 'top'],
   *   ['top'],
   *   ['document', 'defaultView', 'top'],
   *   ['frames', 'top'],
   *   ['globalThis', 'top'],
   *   ['self', 'top']
   * ]
   * ```
   */
  expandPatterns(patterns) {
    const cacheKey = JSONStringify(patterns);
    const cachedValue = expandPatternsCache.get(cacheKey);

    if (cachedValue) {
      return JSONParse(cachedValue);
    }

    const expandedPatterns = patterns.map(pattern => rehydratePattern(normalizePattern(pattern)) // eslint-disable-next-line function-paren-newline
    );
    const dehydratedPatterns = expandedPatterns.map(dehydratePattern);

    for (let i = 0, {
      length
    } = dehydratedPatterns; i < length; i += 1) {
      const arrayPatterns = expandPattern(dehydratedPatterns[i]); // eslint-disable-next-line @typescript-eslint/naming-convention

      for (let j = 0, {
        length: length_j
      } = arrayPatterns; j < length_j; j += 1) {
        const arrayPattern = arrayPatterns[j];
        const stringPattern = dehydratePattern(arrayPattern);

        if (!dehydratedPatterns.includes(stringPattern)) {
          dehydratedPatterns.push(stringPattern);
          expandedPatterns.push(arrayPattern);
        }
      }
    }

    expandPatternsCache.set(cacheKey, JSONStringify(expandedPatterns));
    return expandedPatterns;
  },

  getIdentifierName(node) {
    return node.name;
  },

  getParent(node) {
    return node.parent;
  },

  getType(node) {
    return node.type;
  },

  isMatchableNode(node) {
    if (node) {
      const type = this.getType(node);
      return type === 'Identifier' || type === 'ThisExpression';
    }

    return false;
  },

  isNodeByAsteriskOrName(node, name) {
    if (this.isMatchableNode(node)) {
      return name === ASTERISK_CHARACTER || name === this.getIdentifierName(node) || this.getType(node) === 'ThisExpression';
    }

    return false;
  },

  isNonComputedMemberExpressionNode(node) {
    if (node) {
      return this.getType(node) === 'MemberExpression' && !node.computed;
    }

    return false;
  },

  match(identifier, patterns) {
    const expandedPatterns = this.expandPatterns(ensureArray(patterns));

    expandedLoop: for (let i = 0, {
      length
    } = expandedPatterns; i < length; i += 1) {
      const arrayPattern = expandedPatterns[i]; // Skip fast for mismatched identifiers.

      if (!this.isNodeByAsteriskOrName(identifier, arrayPattern[0])) {
        continue;
      } // Match and exit early for non-member identifier matches.


      if (arrayPattern.length === 1) {
        return {
          identifier,
          node: identifier,
          pattern: dehydratePattern(arrayPattern)
        };
      }

      let currentNode = identifier; // eslint-disable-next-line @typescript-eslint/naming-convention

      for (let j = 0, {
        length: length_j
      } = arrayPattern; j < length_j; j += 1) {
        currentNode = this.getParent(currentNode); // Skip for unexpected nodes.

        if (!this.isNonComputedMemberExpressionNode(currentNode)) {
          continue expandedLoop;
        }

        const {
          object,
          property
        } = currentNode;
        let matchedByPreviousAsterisk = false;

        if (this.isMatchableNode(object)) {
          // Skip for mismatched object identifiers.
          if (!this.isNodeByAsteriskOrName(object, arrayPattern[j])) {
            matchedByPreviousAsterisk = arrayPattern[j - 1] === ASTERISK_CHARACTER;

            if (!matchedByPreviousAsterisk) {
              continue expandedLoop;
            }
          }

          if (!matchedByPreviousAsterisk) {
            j += 1;
          }
        } // Skip nodes that aren't part of a property chain.
        else if (!this.isNonComputedMemberExpressionNode(object)) {
          continue expandedLoop;
        } // Skip for mismatched property identifiers.


        if (!this.isNodeByAsteriskOrName(property, arrayPattern[j])) {
          matchedByPreviousAsterisk = arrayPattern[j - 1] === ASTERISK_CHARACTER;

          if (!matchedByPreviousAsterisk) {
            continue expandedLoop;
          }
        }

        if (matchedByPreviousAsterisk) {
          j -= 1;
        }
      } // If we've made it this far it's a match!


      return {
        identifier,
        node: currentNode,
        pattern: dehydratePattern(arrayPattern)
      };
    }

    return undefined;
  },

  matchAll(identifiers, patterns) {
    const matches = [];

    for (let i = 0, {
      length
    } = identifiers; i < length; i += 1) {
      const identifier = identifiers[i];
      const matchData = this.match(identifier, patterns);

      if (matchData) {
        matches.push(matchData);
      }
    }

    return matches;
  }

};

function createLib(overrides) {
  return _objectSpread(_objectSpread({}, baseLib), overrides);
}

export { createLib };
/*! version: 0.14.7 */
